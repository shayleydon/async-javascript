//https://javascript.info/async-await

/*
Summary

The async keyword before a function has two effects:

    Makes it always return a promise.
    Allows await to be used in it.

The await keyword before a promise makes JavaScript wait until that promise settles, and then:

    If it’s an error, an exception is generated — same as if throw error were called at that very place.
    Otherwise, it returns the result.

Together they provide a great framework to write asynchronous code that is easy to both read and write.

With async/await we rarely need to write promise.then/catch, but we still shouldn’t forget that they are based on promises, because sometimes (e.g. in the outermost scope) we have to use these methods. Also Promise.all is nice when we are waiting for many tasks simultaneously.
*/

async function f() {
  return 1;
}

/*
The word “async” before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.

For instance, this function returns a resolved promise with the result of 1; let’s test it:
*/

async function f() {
  return 1;
}
f().then(alert); // 1

//…We could explicitly return a promise, which would be the same:

async function f() {
  return Promise.resolve(1);
}
f().then(alert); // 1

/*
Await

The syntax:
*/
// works only inside async functions
let value = await promise;
/*
The keyword await makes JavaScript wait until that promise settles and returns its result.

Here’s an example with a promise that resolves in 1 second:
*/
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // wait until the promise resolves (*)

  alert(result); // "done!"
}
f();
/*
The function execution “pauses” at the line (*) and resumes when the promise settles, with result becoming its result. So the code above shows “done!” in one second.

Let’s emphasize: await literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.

It’s just a more elegant syntax of getting the promise result than promise.then. And, it’s easier to read and write.
*/

(async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  ...
})();

/*
Error handling
If a promise resolves normally, then await promise returns the result. But in the case of a rejection, it throws the error, just as if there were a throw statement at that line.
*/

async function f() {
  await Promise.reject(new Error("Whoops!"));
}
//…is the same as this:
async function f() {
  throw new Error("Whoops!");
}

//We can catch that error using try..catch, the same way as a regular throw:
//In the case of an error, the control jumps to the catch block. We can also wrap multiple lines:
async function f() {

  try {
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(err) {
    // catches errors both in fetch and response.json
    alert(err);
  }
}
f();

//If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:
async function f() {
  let response = await fetch('http://no-such-url');
}
// f() becomes a rejected promise
f().catch(alert); // TypeError: failed to fetch // (*)

// wait for the array of results
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
  ...
]);
